// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addShoppingListItemByName = `-- name: AddShoppingListItemByName :exec
INSERT OR IGNORE INTO shopping_list_items(product_id, name, quantity_value, quantity_unit, done)
VALUES (NULL, ?, ?, ?, 0)
`

type AddShoppingListItemByNameParams struct {
	Name          string
	QuantityValue float64
	QuantityUnit  string
}

func (q *Queries) AddShoppingListItemByName(ctx context.Context, arg AddShoppingListItemByNameParams) error {
	_, err := q.db.ExecContext(ctx, addShoppingListItemByName, arg.Name, arg.QuantityValue, arg.QuantityUnit)
	return err
}

const addShoppingListItemByProductID = `-- name: AddShoppingListItemByProductID :exec
INSERT OR IGNORE INTO shopping_list_items(product_id, name, quantity_value, quantity_unit, done)
SELECT p.id, p.name, 1, p.quantity_unit, 0
FROM products p
WHERE p.id = ?
`

func (q *Queries) AddShoppingListItemByProductID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, addShoppingListItemByProductID, id)
	return err
}

const cleanupShoppingListDoneBefore = `-- name: CleanupShoppingListDoneBefore :exec
DELETE FROM shopping_list_items
WHERE
  done = 1
  AND COALESCE(done_at, created_at) < ?
`

func (q *Queries) CleanupShoppingListDoneBefore(ctx context.Context, doneAt interface{}) error {
	_, err := q.db.ExecContext(ctx, cleanupShoppingListDoneBefore, doneAt)
	return err
}

const countProductsFiltered = `-- name: CountProductsFiltered :one
SELECT COUNT(*)
FROM v_products p
WHERE
  (? = 0 OR p.missing = 1 OR p.quantity_value <= p.min_quantity_value)
  AND (? = '' OR lower(p.name) LIKE '%' || lower(?) || '%')
  AND (? = 0 OR p.group_id IN (/*SLICE:group_ids*/?))
`

type CountProductsFilteredParams struct {
	Column1  interface{}
	Column2  interface{}
	LOWER    string
	Column4  interface{}
	GroupIds []interface{}
}

func (q *Queries) CountProductsFiltered(ctx context.Context, arg CountProductsFilteredParams) (int64, error) {
	query := countProductsFiltered
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Column1)
	queryParams = append(queryParams, arg.Column2)
	queryParams = append(queryParams, arg.LOWER)
	queryParams = append(queryParams, arg.Column4)
	if len(arg.GroupIds) > 0 {
		for _, v := range arg.GroupIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_ids*/?", strings.Repeat(",?", len(arg.GroupIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups(name) VALUES (?)
RETURNING id
`

func (q *Queries) CreateGroup(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGroup, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products(name, icon_key, group_id, quantity_value, quantity_unit, min_quantity_value, missing, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id
`

type CreateProductParams struct {
	Name             string
	IconKey          string
	GroupID          interface{}
	QuantityValue    float64
	QuantityUnit     string
	MinQuantityValue float64
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.IconKey,
		arg.GroupID,
		arg.QuantityValue,
		arg.QuantityUnit,
		arg.MinQuantityValue,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteShoppingListItem = `-- name: DeleteShoppingListItem :exec
DELETE FROM shopping_list_items
WHERE id = ?
`

func (q *Queries) DeleteShoppingListItem(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteShoppingListItem, id)
	return err
}

const findProductIDByName = `-- name: FindProductIDByName :one
SELECT id
FROM products
WHERE lower(name) = lower(?)
LIMIT 1
`

func (q *Queries) FindProductIDByName(ctx context.Context, lower string) (int64, error) {
	row := q.db.QueryRowContext(ctx, findProductIDByName, lower)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getShoppingListItem = `-- name: GetShoppingListItem :one
SELECT
  sli.id,
  sli.product_id,
  sli.name,
  COALESCE(p.icon_key, '') AS icon_key,
  COALESCE(g.name, '') AS group_name,
  sli.quantity_value,
  sli.quantity_unit,
  sli.done,
  sli.created_at
FROM shopping_list_items sli
LEFT JOIN products p ON p.id = sli.product_id
LEFT JOIN groups g ON g.id = p.group_id
WHERE sli.id = ?
`

type GetShoppingListItemRow struct {
	ID            int64
	ProductID     sql.NullInt64
	Name          string
	IconKey       string
	GroupName     string
	QuantityValue float64
	QuantityUnit  string
	Done          int64
	CreatedAt     time.Time
}

func (q *Queries) GetShoppingListItem(ctx context.Context, id int64) (GetShoppingListItemRow, error) {
	row := q.db.QueryRowContext(ctx, getShoppingListItem, id)
	var i GetShoppingListItemRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.IconKey,
		&i.GroupName,
		&i.QuantityValue,
		&i.QuantityUnit,
		&i.Done,
		&i.CreatedAt,
	)
	return i, err
}

const linkShoppingListItemToProduct = `-- name: LinkShoppingListItemToProduct :exec
UPDATE shopping_list_items
SET product_id = ?, name = ?
WHERE id = ?
`

type LinkShoppingListItemToProductParams struct {
	ProductID sql.NullInt64
	Name      string
	ID        int64
}

func (q *Queries) LinkShoppingListItemToProduct(ctx context.Context, arg LinkShoppingListItemToProductParams) error {
	_, err := q.db.ExecContext(ctx, linkShoppingListItemToProduct, arg.ProductID, arg.Name, arg.ID)
	return err
}

const listGroups = `-- name: ListGroups :many
SELECT id, name
FROM v_groups
ORDER BY name
`

func (q *Queries) ListGroups(ctx context.Context) ([]VGroup, error) {
	rows, err := q.db.QueryContext(ctx, listGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VGroup
	for rows.Next() {
		var i VGroup
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsAll = `-- name: ListProductsAll :many
SELECT
  p.id,
  p.name,
  p.icon_key,
  p.group_id,
  p.group_name,
  p.quantity_value,
  p.quantity_unit,
  p.min_quantity_value,
  p.missing,
  p.updated_at
FROM v_products p
ORDER BY p.name
`

func (q *Queries) ListProductsAll(ctx context.Context) ([]VProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProductsAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VProduct
	for rows.Next() {
		var i VProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IconKey,
			&i.GroupID,
			&i.GroupName,
			&i.QuantityValue,
			&i.QuantityUnit,
			&i.MinQuantityValue,
			&i.Missing,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsFiltered = `-- name: ListProductsFiltered :many
SELECT
  p.id,
  p.name,
  p.icon_key,
  p.group_id,
  p.group_name,
  p.quantity_value,
  p.quantity_unit,
  p.min_quantity_value,
  p.missing,
  p.updated_at
FROM v_products p
WHERE
  (? = 0 OR p.missing = 1 OR p.quantity_value <= p.min_quantity_value)
  AND (? = '' OR lower(p.name) LIKE '%' || lower(?) || '%')
  AND (? = 0 OR p.group_id IN (/*SLICE:group_ids*/?))
ORDER BY lower(p.name)
LIMIT ?
OFFSET ?
`

type ListProductsFilteredParams struct {
	Column1  interface{}
	Column2  interface{}
	LOWER    string
	Column4  interface{}
	GroupIds []interface{}
	Limit    int64
	Offset   int64
}

func (q *Queries) ListProductsFiltered(ctx context.Context, arg ListProductsFilteredParams) ([]VProduct, error) {
	query := listProductsFiltered
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Column1)
	queryParams = append(queryParams, arg.Column2)
	queryParams = append(queryParams, arg.LOWER)
	queryParams = append(queryParams, arg.Column4)
	if len(arg.GroupIds) > 0 {
		for _, v := range arg.GroupIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_ids*/?", strings.Repeat(",?", len(arg.GroupIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VProduct
	for rows.Next() {
		var i VProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IconKey,
			&i.GroupID,
			&i.GroupName,
			&i.QuantityValue,
			&i.QuantityUnit,
			&i.MinQuantityValue,
			&i.Missing,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsMissingOrLow = `-- name: ListProductsMissingOrLow :many
SELECT
  p.id,
  p.name,
  p.icon_key,
  p.group_id,
  p.group_name,
  p.quantity_value,
  p.quantity_unit,
  p.min_quantity_value,
  p.missing,
  p.updated_at
FROM v_products p
WHERE p.missing = 1 OR p.quantity_value <= p.min_quantity_value
ORDER BY p.name
`

func (q *Queries) ListProductsMissingOrLow(ctx context.Context) ([]VProduct, error) {
	rows, err := q.db.QueryContext(ctx, listProductsMissingOrLow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VProduct
	for rows.Next() {
		var i VProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IconKey,
			&i.GroupID,
			&i.GroupName,
			&i.QuantityValue,
			&i.QuantityUnit,
			&i.MinQuantityValue,
			&i.Missing,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShoppingListItems = `-- name: ListShoppingListItems :many
SELECT
  sli.id,
  sli.product_id,
  sli.name,
  COALESCE(p.icon_key, '') AS icon_key,
  COALESCE(g.name, '') AS group_name,
  sli.quantity_value,
  sli.quantity_unit,
  sli.done,
  sli.created_at
FROM shopping_list_items sli
LEFT JOIN products p ON p.id = sli.product_id
LEFT JOIN groups g ON g.id = p.group_id
ORDER BY sli.created_at DESC, sli.id DESC
`

type ListShoppingListItemsRow struct {
	ID            int64
	ProductID     sql.NullInt64
	Name          string
	IconKey       string
	GroupName     string
	QuantityValue float64
	QuantityUnit  string
	Done          int64
	CreatedAt     time.Time
}

func (q *Queries) ListShoppingListItems(ctx context.Context) ([]ListShoppingListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listShoppingListItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShoppingListItemsRow
	for rows.Next() {
		var i ListShoppingListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.IconKey,
			&i.GroupName,
			&i.QuantityValue,
			&i.QuantityUnit,
			&i.Done,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveProductIconKeyByName = `-- name: ResolveProductIconKeyByName :one
SELECT icon_key
FROM product_icon_rules
WHERE lower(?) LIKE '%' || lower(match_substring) || '%'
ORDER BY priority DESC, id DESC
LIMIT 1
`

func (q *Queries) ResolveProductIconKeyByName(ctx context.Context, lower string) (string, error) {
	row := q.db.QueryRowContext(ctx, resolveProductIconKeyByName, lower)
	var icon_key string
	err := row.Scan(&icon_key)
	return icon_key, err
}

const setProductGroup = `-- name: SetProductGroup :exec
UPDATE products
SET group_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetProductGroupParams struct {
	GroupID interface{}
	ID      int64
}

func (q *Queries) SetProductGroup(ctx context.Context, arg SetProductGroupParams) error {
	_, err := q.db.ExecContext(ctx, setProductGroup, arg.GroupID, arg.ID)
	return err
}

const setProductMinQuantity = `-- name: SetProductMinQuantity :exec
UPDATE products
SET min_quantity_value = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetProductMinQuantityParams struct {
	MinQuantityValue float64
	ID               int64
}

func (q *Queries) SetProductMinQuantity(ctx context.Context, arg SetProductMinQuantityParams) error {
	_, err := q.db.ExecContext(ctx, setProductMinQuantity, arg.MinQuantityValue, arg.ID)
	return err
}

const setProductMissing = `-- name: SetProductMissing :exec
UPDATE products
SET missing = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetProductMissingParams struct {
	Missing int64
	ID      int64
}

func (q *Queries) SetProductMissing(ctx context.Context, arg SetProductMissingParams) error {
	_, err := q.db.ExecContext(ctx, setProductMissing, arg.Missing, arg.ID)
	return err
}

const setProductQuantity = `-- name: SetProductQuantity :exec
UPDATE products
SET quantity_value = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetProductQuantityParams struct {
	QuantityValue float64
	ID            int64
}

func (q *Queries) SetProductQuantity(ctx context.Context, arg SetProductQuantityParams) error {
	_, err := q.db.ExecContext(ctx, setProductQuantity, arg.QuantityValue, arg.ID)
	return err
}

const setProductUnit = `-- name: SetProductUnit :exec
UPDATE products
SET quantity_unit = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetProductUnitParams struct {
	QuantityUnit string
	ID           int64
}

func (q *Queries) SetProductUnit(ctx context.Context, arg SetProductUnitParams) error {
	_, err := q.db.ExecContext(ctx, setProductUnit, arg.QuantityUnit, arg.ID)
	return err
}

const setShoppingListItemDone = `-- name: SetShoppingListItemDone :exec
UPDATE shopping_list_items
SET
  done = ?,
  done_at = CASE WHEN ? = 1 THEN CURRENT_TIMESTAMP ELSE NULL END
WHERE id = ?
`

type SetShoppingListItemDoneParams struct {
	Done    int64
	Column2 interface{}
	ID      int64
}

func (q *Queries) SetShoppingListItemDone(ctx context.Context, arg SetShoppingListItemDoneParams) error {
	_, err := q.db.ExecContext(ctx, setShoppingListItemDone, arg.Done, arg.Column2, arg.ID)
	return err
}

const setShoppingListItemQuantity = `-- name: SetShoppingListItemQuantity :exec
UPDATE shopping_list_items
SET quantity_value = ?, quantity_unit = ?
WHERE id = ?
`

type SetShoppingListItemQuantityParams struct {
	QuantityValue float64
	QuantityUnit  string
	ID            int64
}

func (q *Queries) SetShoppingListItemQuantity(ctx context.Context, arg SetShoppingListItemQuantityParams) error {
	_, err := q.db.ExecContext(ctx, setShoppingListItemQuantity, arg.QuantityValue, arg.QuantityUnit, arg.ID)
	return err
}

const suggestProductsByName = `-- name: SuggestProductsByName :many
SELECT
  id,
  name,
  icon_key,
  quantity_unit
FROM products
WHERE lower(name) LIKE '%' || lower(?) || '%'
ORDER BY lower(name)
LIMIT ?
`

type SuggestProductsByNameParams struct {
	LOWER string
	Limit int64
}

type SuggestProductsByNameRow struct {
	ID           int64
	Name         string
	IconKey      string
	QuantityUnit string
}

func (q *Queries) SuggestProductsByName(ctx context.Context, arg SuggestProductsByNameParams) ([]SuggestProductsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, suggestProductsByName, arg.LOWER, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SuggestProductsByNameRow
	for rows.Next() {
		var i SuggestProductsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IconKey,
			&i.QuantityUnit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
